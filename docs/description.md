# ER-схема базы данных

![database](images/database.png)
<!-- <img src="./images/database.png" alt="database" width="1000" height="550"> -->

## Отношения между сущностями:

### 1. User <---> UserRole (One-to-Many)
- Один пользователь может иметь несколько ролей (например, "manager" или "employee"), при этом хотя бы одну (сейчас это не реализовано, поэтому на данный момент будет правильнее написать "..., либо не иметь вообще.").
- Одна роль принадлежит одному пользователю, либо не принадлежит никому.

### 2. User <---> Course (One-to-Many)
- Один пользователь с ролью "manager" может создать несколько курсов, либо не создать ни одного.
- Один курс может быть создан обязательно одним и только одним пользователем с ролью "manager".

### 3. User <---> CourseEmployee <---> Course (Many-to-Many)
- Один пользователь с ролью "employee" может проходить несколько курсов, либо не проходить ни одного.
- Один курс могут проходить сразу несколько пользователей с ролью "employee", а может не проходить ни один.

### 4. Course <---> CourseContent (One-to-Many)
- Один курс может иметь несколько видов контента (задание или теория), либо вообще их не иметь.\
ВАЖНО: Курс НЕобязательно должен иметь какой-либо вид контента!
- Каждый вид контена обязательно связан с одним и только с одним курсом.

### 5. CourseContent <---> Task (One-to-One)
- Элемент контента может являться заданием.

### 6. CourseContent <---> Theory (One-to-One)
- Элемент контента может являться теорией.

### 7. CourseContent <---> Comment (One-to-Many)
- Один элемент контента может иметь несколько комментариев, либо вообще их не иметь.
- Каждый комментарий обязательно относится к одному и только одному элементу контента.

### 8. User <---> Comment (One-to-Many)
- Один пользователь может оставить несколько комментариев, либо не оставлять их вообще.
- Каждый комментарий обязательно написан одним и только одинм пользователем.

### 9. CourseEmployee <---> CourseEmployeeContent (One-to-Many)
- Один объект CourseEmployee (назначение сотрудника на курс) может иметь несколько статусов прохождения содержимого курса.
- Каждый статус прохождения контента относится к одному и только одному CourseEmployee.

### 10. Content <---> CourseEmployeeContent (One-to-Many)
- Один элемент контента (задание или теория) может иметь несколько статусов прохождения у разных сотрудников.
- Каждый статус прохождения контента относится к одному и только одному элементу контента.

### 13. User <---> Notification (One-to-Many)
- Один пользователь может иметь множество уведомлений, либо не иметь их вовсе.
- Каждое уведомление обязательно принадлежит одному и только одному пользователю.

---

## Каскадное удаление:

### 1. User --> UserRole (cascade="all, delete-orphan"):
- Удаление пользователя влечёт за собой удаление всех связей с его ролями.

### 2. User --> manager_courses (Course.manager_id, ondelete='CASCADE'):
- Удаление пользователя влечёт за собой удаление всех курсов, которые он создал.

### 3. User --> employee_courses (CourseEmployee.employee_id, ondelete='CASCADE'):
- Удаление пользователя влечёт за собой удаление всех всех связей с курсами, на которые он записался.

### 4. User --> comments (Comment.user_id, ondelete='CASCADE'):
- Удаление пользователя приводит к удалению всех его комментариев.

### 5. User --> notifications (Notification.user_id, ondelete='CASCADE'):
- При удалении пользователя удаляются все его уведомления.

### 6. Course --> contents (Content.course_id, ondelete='CASCADE'):
- Удаление курса вызывает удаление всех его элементов контента.

### 7. Course --> course_employees (CourseEmployee.course_id, ondelete='CASCADE'):
- При удалении курса удаляются все связи этого курса с пользователями, которые были записаны на этот курс.

### 8. Content --> comments (Comment.content_id, ondelete='CASCADE'):
- Удаление содержимого курса удаляет все комментарии к нему.

### 9. Content --> course_employee_contents (CourseEmployeeContent.content_id, ondelete='CASCADE'):
- Удаление содержимого курса приводит к удалению всех статусов прохождения элементов контента пользователями.

### 10. Content --> task_id/theory_id (ondelete='CASCADE') + single_parent=True:
- Удаление содержимого удаляет связанные задачи (Task) и теории (Theory), если они не используются в других элементах контента.

### 11. CourseEmployee --> course_employee_contents (ondelete='CASCADE'):
- При удалении записи о назначении сотрудника на курс удаляются все статусы прохождения элементов контента этого сотрудника.

---

## Бизнес-логика, реализованная с помощью триггеров:

### 1. check_content_type_task_theory.sql:  
- Гарантирует, что для каждого элемента контента (contents) заполнено ровно одно из полей: task_id или theory_id. Нельзя одновременно указывать обе ссылки или не указывать ни одной.

### 2. check_user_role_before_create_course.sql:  
- Проверяет, что курс может создавать или обновлять только пользователь с ролью manager. Если у пользователя нет этой роли, операция блокируется.

### 3. check_user_role_before_register_course.sql:  
- Обеспечивает, что на курс могут регистрироваться только пользователи с ролью employee. Кроме того, запрещает пользователю регистрироваться на курс, который он сам создал.

### 4. protect_produced_content_update.sql:  
- После того как курс помечен как "produced" (готовый к использованию), защищает связанные с ним элементы контента от изменения ключевых полей (название, ссылки на задания/теорию и т.п.), разрешая изменять только дедлайн.

### 5. protect_produced_course_update.sql:  
- После публикации курса (is_produced = TRUE) защищает курс от изменения основных полей (название, менеджер, статус, дата создания). Разрешает обновлять только описание и дедлайн.

### 6. protect_task_update_after_production.sql:  
- Запрещает обновлять задания (tasks), если они уже связаны с контентом курса, который был опубликован (is_produced = TRUE).

### 7. protect_theory_update_after_production.sql:  
- Аналогично предыдущему, запрещает обновлять теории (theories), связанные с опубликованым курсом.

### 8. validate_course_deadline.sql:  
- Обеспечивает, что дедлайн курса не может быть установлен раньше, чем максимальный дедлайн среди всех элементов контента этого курса. Это предотвращает логические несоответствия в сроках.

### 9. create_employee_content_statuses.sql:  
- Автоматически создаёт записи со статусом 'pending' для каждого элемента контента курса при добавлении нового пользователя на курс (course_employee). Это позволяет отслеживать прогресс выполнения контента каждым пользователем.

### 10. prevent_enroll_unproduced_courses.sql:  
- Запрещает регистрацию пользователя на курс, если курс ещё не опубликован (is_produced = FALSE). Это исключает участие в неактивных или незавершённых курсах.

### 11. notify_course_deletion.sql:  
- При удалении курса создаёт уведомление для менеджера курса с сообщением о том, что он удалил свой курс.

### 12. notify_employee_course_completed.sql:  
- Отслеживает прогресс пользователя в курсе и при достижении необходимого процента выполнения (passing_percent) создаёт уведомления для самого пользователя об успешном завершении и для менеджера курса о том, что пользователь успешно закончил курс. Также обновляет статус завершения курса для пользователя.

### 13. notify_manager_course_comment.sql:  
- При добавлении комментария к контенту курса отправляет уведомление менеджеру курса, если комментарий оставлен не им самим, чтобы менеджер был в курсе обратной связи от пользователей.

### 14. notify_manager_course_created.sql:  
- После того как курс изменил статус с "не опубликованный" на "опубликованный" (is_produced = TRUE), отправляет уведомление менеджеру о публикации курса.

### 15. notify_manager_course_enrollment.sql:  
- При регистрации пользователя на курс отправляет уведомление менеджеру курса о том, что пользователь записался на этот курс.

---

## Проблемы на данный момент:

- С помощью триггеров нельзя реализовать проверку на то, что пользователь должен иметь хотя бы одну роль (например, "manager" или "employee").
- Для хранения статусов элементов контента для каждого пользователя для каждого курса используется таблица в базе данных (course_employee_contents). Но такое решение не самое эффективное, т.к. сложность хранения данных равна O(N * M * K), где N - колиичество пользователей, M - колиичество курсов, K - колиичество элементов контента курса, т.е. сложность хранения данных O(N**3). Для таких задач лучше использовать Redis.
- С помощью триггеров нельзя реализовать механизм создания уведомлений при удалении курса для пользователей, который были записаны на этот курс.
